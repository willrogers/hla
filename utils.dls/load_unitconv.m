function load_unitconv(ringmode)
dir = fileparts(mfilename('fullpath'));
cd(dir);
ini_file = fullfile(dir, '..', 'aphla', 'machines', ringmode, 'unitconv.ini');


fprintf('Loading unit conversions to file %s\n', ini_file);

f = fopen(ini_file, 'w');
fprintf(f, '# Unit conversions generated by load_unitconv.m.\n\n');

quad_families = findmemberof('QUAD');
sext_families = findmemberof('SEXT');

for i = 1:length(quad_families)
    write_multipole_section(f, quad_families{i}, 'b1', 'm^-2');
end

for i = 1:length(sext_families)
    write_multipole_section(f, sext_families{i}, 'b2', 'm^-3');
end

bend_families = findmemberof('BEND');
for i = 1:length(bend_families)
    coeffs = get_poly_coeffs(bend_families{i}, 1, false);
    write_section(f, bend_families{i}, 'b0', 'A', 'rad', coeffs);
end

write_section(f, 'BPM', 'x', 'mm', 'm', [0, 0, 0, 0.001, 0]);
write_section(f, 'BPM', 'y', 'mm', 'm', [0, 0, 0, 0.001, 0]);

% If corrector magnets are windings on a sextupole, their AT Index is that
% of the sextupole.  We have to reverse that.
sext_data = getfamilydata('SEXT_');
sext_indices = sext_data.AT.ATIndex;

hcor = getfamilydata('HCM');
for i = 1:length(hcor.DeviceList)
    coeffs = get_poly_coeffs('HCM', i, false);
    hcor_index = hcor.AT.ATIndex(i);
    if any(hcor_index == sext_indices)
        hcor_index = hcor_index + 1;
    end
    write_section(f, num2str(hcor_index), 'b0', 'A', 'rad', coeffs);
end

vcor = getfamilydata('VCM');
for i = 1:length(vcor.DeviceList)
    coeffs = get_poly_coeffs('VCM', i, false);
    vcor_index = vcor.AT.ATIndex(i);
    if any(vcor_index == sext_indices)
        vcor_index = vcor_index + 2;
    end
    write_section(f, num2str(vcor_index), 'b0', 'A', 'rad', coeffs);
end

fclose(f);

end


function write_section(file, group, field, src_unit, dst_unit, coeffs)

    fprintf(file, '[%s(%s)]\n', group, field);
    fprintf(file, 'dst_unit_sys: phy\n');
    fprintf(file, 'src_unit: %s\n', src_unit);
    fprintf(file, 'dst_unit: %s\n', dst_unit);
    fprintf(file, 'polynomial: %0.15f %0.15f %0.15f %0.15f %0.15f\n', coeffs);
    fprintf(file, 'groups: %s\n', group);
    fprintf(file, 'field: %s\n\n', field);

end


function write_multipole_section(f, family, field, units)
    % We need to get our own device list so we can set the StatusFlag to 0,
    % this returns devices which are currently disabled.
    device_list = family2dev(family, 0);
    a = hw2physics(family, 'Monitor', 100, device_list);
    if all(a / a(1) == 1)  % All the magnets in the family have the same
                           % unit conversion.
        coeffs = get_linear_coeffs(family, 1, false);
        write_section(f, family, field', 'A', units, coeffs);
    else  % Need unit conversion data for each magnet in the family.
        irregular_mags = getfamilydata(family);
        for j = 1:length(irregular_mags.DeviceList)
            coeffs = get_linear_coeffs(family, j, false);
            q_index = irregular_mags.AT.ATIndex(j);
            write_section(f, num2str(q_index), field, 'A', units, coeffs);
        end
    end
end


function coeffs = get_linear_coeffs(family, devices, plot_graph)
    % Manually derive a linear fit by changing the physics value by
    % a small amount and determining the change in hardware values.
    % I found this to be closer to the MML behaviour for quadrupoles.
    DELTA = 0.1; % Hard-code a 'small' value.
    phys0 = getpv(family, 'Physics', devices);
    sp0 = getpv(family, 'Hardware', devices);
    sp1 = sp0 + DELTA;
    setpv(family, sp1, 'Hardware', devices);
    phys1 = getpv(family, 'Physics', devices);
    gradient = (phys1 - phys0) ./ (sp1 - sp0);
    offset = phys0 - gradient .* sp0;
    % Return setpoint to initial value.
    setpv(family, sp0, 'Hardware', devices);
    zs = zeros(length(phys0), 1);
    coeffs = [zs zs zs gradient offset];
end


function coeffs = get_poly_coeffs(family, devices, plot_graph)
    % Create a polynomial directly from the raw calibration data
    % stored by MML.
    cal_data = get_cal_data(family);
    current_max = max(cal_data.current);
    if current_max < 0
        current_max = 0;
    end
    current_min = min(cal_data.current);
    if current_min > 0
        current_min = 0;
    end
    range = current_min:1:current_max;
    cal = [];
    for j = 1:length(range)
        cal(j) = hw2physics(family, 'Monitor', range(j), devices);
    end
    coeffs = polyfit(range, cal, 4);
    disp(coeffs);
    
    if plot_graph
        plot(cal_data.current, cal_data.field, 'x');
        hold on
        brho = 10.069;
        f = @(x) coeffs(1) .* x .^4 + coeffs(2) .* x .^3 + coeffs(3) .* x .^2 + coeffs(4) .* x + coeffs(5);
        plot(range, f(range) * brho, 'r');
        plot(range, cal * brho, 'g');
    end
   
end


function cal_data = get_cal_data(famname)

    global calibration_data;

    disp(famname);
    fd = getfamilydata(famname);
    chan = fd.Monitor.ChannelNames(1,:);
    index = calibration_lookup2(chan);
    cal_data = calibration_data{index};
    disp(cal_data);
    
end
